import type { Compiler, WebpackError } from "webpack";

import type { GenerateSWConfig } from "./core.js";
import { generateSW } from "./core.js";

const generatedAssetNames = new Set<string>();

interface GenerateSWWebpackConfig extends GenerateSWConfig {
  exclude?: (string | ((_: { asset: { name: string } }) => boolean))[];
}

export class GenerateSW {
  protected config: GenerateSWWebpackConfig;

  protected propagateConfigWithCompiler(compiler: Compiler): void {
    // Properties that are already set take precedence over derived
    // properties from the compiler.
    this.config = Object.assign(
      {
        mode: compiler.options.mode,
      },
      this.config
    );
  }

  /**
   * @param compilation The webpack compilation.
   */
  protected async addAssets(): Promise<void> {
    const config = this.config;

    if (!config.exclude) {
      config.exclude = [];
    }

    // Ensure that we don't precache any of the assets generated by *any*
    // instance of this plugin.
    config.exclude.push(({ asset }) => generatedAssetNames.has(asset.name));

    generateSW(config);
  }

  /**
   * Creates an instance of GenerateSW.
   */
  constructor(config: GenerateSWWebpackConfig) {
    this.config = config;
  }

  /**
   * @param compiler Default compiler object passed from webpack
   */
  apply(compiler: Compiler): void {
    this.propagateConfigWithCompiler(compiler);

    const { PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER } =
      compiler.webpack.Compilation;
    // Specifically hook into thisCompilation, as per
    // https://github.com/webpack/webpack/issues/11425#issuecomment-690547848
    compiler.hooks.thisCompilation.tap(this.constructor.name, (compilation) => {
      compilation.hooks.processAssets.tapPromise(
        {
          name: "GenerateSW",
          stage: PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER - 10,
        },
        () =>
          this.addAssets().catch((error: WebpackError) => {
            compilation.errors.push(error);
          })
      );
    });
  }
}
